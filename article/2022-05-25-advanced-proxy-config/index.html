<!DOCTYPE html><html lang="zh-cn" data-color-mode="light"><head><meta charSet="utf-8"/><link rel="shortcut icon" href="/medias/favicon.png"/><meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/><meta content="on" http-equiv="x-dns-prefetch-control"/><meta content="telephone=no" name="format-detection"/><title>webpack和vite devServer的进阶用法：配置proxy修改请求和响应 | liyang&#x27;s  blog</title><meta name="keywords" content="vite webpack proxy"/><meta name="description" content="在前端日常开发中我们一般都是配置本地开发服务器的proxy来解决跨域问题，查看官网文档或者通过搜索引擎搜出来的都是比较基础的用法：
 proxy: &amp;#123;
     &amp;#39;/api/&amp;#39;: &amp;#123;
         target: &amp;#39;http://dev.test.com&amp;#39;
     &amp;#125;
 &amp;#125;

我最近有这么一个需求，需要修改请求头里的一些……"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/59727fef85d99607.css" as="style"/><link rel="stylesheet" href="/_next/static/css/59727fef85d99607.css" data-n-g=""/><noscript data-n-css=""></noscript></head><body><div id="__next" data-reactroot=""><div class="blog-header min-w-full"><div class="container max-w-screen-lg px-2 clear-both"><div class="block text-center sm:inline-block sm:text-left "><div class=" inline-block align-top rounded-full my-2 mr-2 w-8 h-8 overflow-hidden bg-blue-400"><img class="site-logo" src="/medias/avatar.jpg" alt=""/></div><span class=" inline-block align-top mt-2.5 text-xl">liyang&#x27;s  blog</span></div><div class="block text-center sm:inline-block sm:text-left sm:float-right"><a class="inline-block nav-link py-3 px-2" href="/">首页</a><a class="inline-block nav-link py-3 px-2" href="/archives/">归档</a><a class="inline-block nav-link py-3 px-2" href="/gallery/">相册</a><a class="inline-block nav-link py-3 px-2" href="/about/">关于</a><span class="inline-block nav-link py-3 px-2" id="btn_toggle_theme" title="切换暗色模式"><i class="theme-icon"></i></span></div></div></div><div class="blog-body pt-10 pb-10"><div class="container max-w-screen-lg px-3"><main class="flex"><article class="article-content mb-5 rounded p-5 w-full "><h1 class="text-xl md:text-2xl lg:text-2xl font-bold tracking-tighter leading-tight md:leading-none mb-6 text-center md:text-left">webpack和vite devServer的进阶用法：配置proxy修改请求和响应</h1><p class="mb-5 text-sm"><span class="mr-3">发布日期：<!-- -->2022-05-25</span><span>文章字数：<!-- -->1.3<!-- -->K</span></p><div class="mx-auto"><div class="markdown-body"><p>在前端日常开发中我们一般都是配置本地开发服务器的proxy来解决跨域问题，查看官网文档或者通过搜索引擎搜出来的都是比较基础的用法：</p>
<pre><code> proxy: &#123;
     &#39;/api/&#39;: &#123;
         target: &#39;http://dev.test.com&#39;
     &#125;
 &#125;
</code></pre>
<p>我最近有这么一个需求，需要修改请求头里的一些东西，我最初使用node启动一个本地服务来做代理，后面我觉得有点麻烦，每次开发都要手动来开启。后来又瞄了下vue-cli的官网，里面提到：如果你想要更多的代理控制行为，也可以使用一个 path: options 成对的对象。完整的选项可以查阅 <a href="https://github.com/chimurai/http-proxy-middleware#proxycontext-config">http-proxy-middleware</a> </p>
<p>页面里给出了如下的代码：</p>
<pre><code class="js">createProxyMiddleware(&#123;
  target: &#39;http://www.example.org&#39;,
  on: &#123;
    proxyReq: (proxyReq, req, res) =&gt; &#123;
      /* handle proxyReq */
    &#125;,
    proxyRes: (proxyRes, req, res) =&gt; &#123;
      /* handle proxyRes */
    &#125;,
    error: (err, req, res) =&gt; &#123;
      /* handle error */
    &#125;,
  &#125;,
&#125;);
</code></pre>
<p>看到上述代码，你可能会直接把on那里面的东西直接复制到上面配置的target下面，不过我尝试了之后，并没有生效。我搜索了一下http-proxy-middleware之后，搜到了如下的代码，经过测试之后，确定可用，文章原文地址：<a href="https://juejin.cn/post/6993644913900388359">https://juejin.cn/post/6993644913900388359</a> ，下面是正确的配置选项：</p>
<pre><code class="js">
module.exports = &#123;
  //...
  devServer: &#123;
    //...
    proxy: &#123;
      &#39;/api/&#39;: &#123;
        target: &#39;http://www.abc.com&#39;,
        changeOrigin: true,
        onProxyReq: (proxyReq, req, res) =&gt; &#123;
          proxyReq.removeHeader(&#39;referer&#39;)  //移除请求头
          proxyReq.removeHeader(&#39;origin&#39;) //移除请求头
          proxyReq.setHeader(&#39;origin&#39;,&#39;www.abc.com&#39;) //添加请求头
          proxyReq.setHeader(&#39;host&#39;,&#39;www.abc.com&#39;) //添加请求头
        &#125;,
        onProxyRes: (proxyRes, req, res) =&gt; &#123;
          /*添加或删除响应头有两种写法，第一种是操作 proxyRes 参数*/
          delete proxyRes.headers[&#39;set-cookie&#39;]
          proxyRes.headers[&#39;set-cookie&#39;] = &#39;new cookie value&#39;;

          /*第二种方法是操作 res 参数*/
          res.removeHeader(&quot;Access-Control-Allow-Origin&quot;);
          res.setHeader(&quot;Access-Control-Allow-Origin&quot;, req.headers.origin);
          res.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &#39;true&#39;);
          res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;);
          res.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);
        &#125;,
      &#125;
    &#125;
  &#125;
&#125;

</code></pre>
<p>上面的代码是移除请求头里面的referer和origin字段，因为我要请求的api对这个字段进行了校验，我们前端本地的服务器一般是localhost:8080之类的，通过浏览器请求携带的是本地地址，api拒绝请求，移除和修改这些请求头之后，就可以正常请求api了。如果你想修改api响应的数据，写在proxyRes事件里，上面proxyRes里的代码示例是添加允许跨域的响应头。</p>
<p>最近vite也逐渐流行起来，我最近在新项目中也开始使用vite，查看了vite官网文档，官网给出了如下用法：</p>
<pre><code class="js">&#39;/api&#39;: &#123;
        target: &#39;http://jsonplaceholder.typicode.com&#39;,
        changeOrigin: true,
        configure: (proxy, options) =&gt; &#123;
          // proxy 是 &#39;http-proxy&#39; 的实例
        &#125;
      &#125;
</code></pre>
<p>更详细的用法指向了如下地址：<a href="https://github.com/http-party/node-http-proxy#listening-for-proxy-events">https://github.com/http-party/node-http-proxy#listening-for-proxy-events</a></p>
<p>里面代码如下：</p>
<pre><code class="js">
proxy.on(&#39;proxyRes&#39;, function (proxyRes, req, res) &#123;
  console.log(&#39;RAW Response from the target&#39;, JSON.stringify(proxyRes.headers, true, 2));
&#125;);
</code></pre>
<p>直接将上述代码复制到configure里面就可以运行了，下面是示例：</p>
<pre><code class="js">export default &#123;
  //...
  server:&#123;
    //...
    proxy: &#123;
      &#39;/api/&#39;: &#123;
        target: &#39;http://www.abc.com&#39;,
        changeOrigin: true,
        prependPath: true,
        configure: (proxy, options) =&gt; &#123;
          proxy.on(&#39;proxyReq&#39;, function (proxyReq, req, res) &#123;
            proxyReq.removeHeader(&#39;referer&#39;)  //移除请求头
            proxyReq.removeHeader(&#39;origin&#39;) //移除请求头
            proxyReq.setHeader(&#39;host&#39;,&#39;www.abc.com&#39;) //添加请求头
          &#125;);
          proxy.on(&#39;proxyRes&#39;, function (proxyRes, req, res) &#123;
            /*添加或删除响应头有两种写法，第一种是操作 proxyRes 参数*/
            delete proxyRes.headers[&#39;set-cookie&#39;]
            proxyRes.headers[&#39;set-cookie&#39;] = &#39;new cookie value&#39;;

            /*第二种方法是操作 res 参数*/
            res.removeHeader(&quot;Access-Control-Allow-Origin&quot;);
            res.setHeader(&quot;Access-Control-Allow-Origin&quot;, req.headers.origin);
            res.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &#39;true&#39;);
            res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;);
            res.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);
          &#125;);
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面示例均是将地址&#x2F;api&#x2F;的请求转发到<a href="http://www.abc.com/">www.abc.com</a> ，例：本地地址：127.0.0.1:8080&#x2F;api&#x2F;getUserInfo，目标api是:<a href="http://www.abc.com/api/getUserInfo">www.abc.com/api/getUserInfo</a> 。<br>以上示例之给出了proxyReq事件，完整事件如下(机翻)：</p>
<pre><code class="js">error：如果对目标的请求失败，则会发出错误事件。我们不对客户端和代理之间传递的消息以及代理和目标之间传递的消息进行任何错误处理，因此建议您侦听错误并进行处理。
proxyReq：在发送数据之前发出此事件。它使您有机会更改 proxyReq 请求对象。适用于“网络”连接
proxyReqWs：在发送数据之前发出此事件。它使您有机会更改 proxyReq 请求对象。适用于“websocket”连接
proxyRes：如果对目标的请求得到响应，则会发出此事件。
open：一旦创建代理 websocket 并将其通过管道传输到目标 websocket，就会发出此事件。
close：一旦代理 websocket 关闭，就会触发此事件。
proxySocket（已弃用）：建议使用open.
</code></pre>
</div><p class="date-info pt-8 font-bold leading-10 text-center hidden">本文发布于天前，文中所描述的信息可能已发生改变</p></div></article></main></div></div><footer class="blog-footer bg-neutral-50 border-neutral-200"><div class="container max-w-screen-lg px-3"><div class="md:flex justify-between block text-sm py-2"><div class="py-1 mx-3 text-center">Copyright © 2019 - 2022 <!-- -->liyang&#x27;s  blog<a href="http://beian.miit.gov.cn/"> 豫ICP备19028870号 </a></div><div class="py-1 mx-3 text-center"> Powered by<a href="https://nextjs.org/"> Next.js </a>&amp;<a href="https://hexo.io/"> Hexo </a>Created by liyang</div></div></div></footer></div></body><script id="DarkModeScript">
    let html = document.documentElement;
    let  colorScheme = localStorage.getItem('colorScheme')
    if(colorScheme&&colorScheme=='dark'){
      html.setAttribute('data-color-mode', 'dark')
    } else {
      html.setAttribute('data-color-mode', 'light')
    }
    let btn_toggle_theme = document.querySelector('#btn_toggle_theme');
    btn_toggle_theme.addEventListener('click', function () {
    let theme = html.dataset.colorMode;
      if (theme == 'light') {
        html.setAttribute('data-color-mode', 'dark')
        localStorage.setItem('colorScheme','dark');
      } else if (theme == 'dark') {
        html.setAttribute('data-color-mode', 'light')
        localStorage.setItem('colorScheme','light');
      }
    })</script><script id="DynamicLoadScript">
function PromiseForEach(arr, cb) {
    let realResult = []
    let result = Promise.resolve()
    arr.forEach((a, index) => {
      result = result.then(() => {
        return cb(a).then((res) => {
          realResult.push(res)
        })
      })
    })
    return result.then(() => {
      return realResult
    })
 }
function addScript(url) {
   return new Promise((resolve, reject) => {
     let script = document.createElement('script');
     script.src = url;
     document.documentElement.appendChild(script);
     script.onload = ()=>{
       return resolve('success')
     }
     script.onerror = ()=>{
       return reject('error')
     }
   })
 }     
function AddCss(url) {
      document.head.insertAdjacentHTML("beforeend", `<link rel="stylesheet" href="${url}">`);
}
</script><script id="ArticleTocScript">
       window.articleDate = '2022-05-25';
      let tocLinks = document.querySelectorAll('.toc-text');
      let targetLinks = document.querySelectorAll('.headerlink')
      tocLinks.forEach(function (link) {
        link.addEventListener('click', function (event) {
        let target = event.target
        event.preventDefault()
        event.stopPropagation()
        let parent = target.parentNode;
        let hash = decodeURI(parent.hash);
        let targetLink = Array.prototype.find.call(targetLinks, function (item) {
          return item.getAttribute('href') == hash
        })
        let top = targetLink.offsetTop
        window.scrollTo(0, top - 100)
        })
      })
      let dateInfoEle = document.querySelector('.date-info');
      var articleDate = new Date(window.articleDate)
    if(new Date().getTime()-articleDate.getTime()>180 * 24 * 3600 *1000){
      let date = Math.ceil((new Date().getTime()-articleDate.getTime())/24/3600/1000)
      dateInfoEle.style.display = 'block';
      dateInfoEle.innerText = `本文发布于${date}天前，文中所描述的信息可能已发生改变。`
    }
addScript('https://unpkg.com/@highlightjs/cdn-assets@11.5.0/highlight.min.js').then(res => {
   document.querySelectorAll('pre code').forEach((el) => {
    hljs.highlightElement(el);
  });
})     
      </script><script id="StatisticScript">
let runningOnBrowser = typeof window !== "undefined";
    let isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
let supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
    if(!isBot&&supportsIntersectionObserver){
      if(!navigator.userAgent.includes('Chrome/78')){
        addScript('https://hm.baidu.com/hm.js?3123469f7f81d45d6c4cd4a6a84ccf68');
        addScript('https://js.users.51.la/21306481.js');
      }
    }
  </script></html>