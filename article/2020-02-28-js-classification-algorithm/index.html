<!DOCTYPE html><html lang="zh-cn" data-color-mode="light"><head><meta charSet="utf-8"/><link rel="shortcut icon" href="/medias/favicon.png"/><meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/><meta content="on" http-equiv="x-dns-prefetch-control"/><meta content="telephone=no" name="format-detection"/><title>一个js数组分类求和算法 | liyang&#x27;s  blog</title><meta name="keywords" content="JavaScript 算法"/><meta name="description" content="需求详情：一个数组内有N个元素，元素有类型、名称、数量1、数量2等属性，计算出各类型元素的数量、数量1、数量2的和。
实际需求就是做出下图这样一个表格，各类型的合计信息用红色字体显示：

原始数据格式如下：
const rawData = [
      &amp;#123; type: &amp;#39;类型A&amp;#39;, name: &amp;#39;名称1&amp;#39;, count1: 13, count2: 24,……"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/59727fef85d99607.css" as="style"/><link rel="stylesheet" href="/_next/static/css/59727fef85d99607.css" data-n-g=""/><noscript data-n-css=""></noscript></head><body><div id="__next" data-reactroot=""><div class="blog-header min-w-full"><div class="container max-w-screen-lg px-2 clear-both"><div class="block text-center sm:inline-block sm:text-left "><div class=" inline-block align-top rounded-full my-2 mr-2 w-8 h-8 overflow-hidden bg-blue-400"><img class="site-logo" src="/medias/avatar.jpg" alt=""/></div><span class=" inline-block align-top mt-2.5 text-xl">liyang&#x27;s  blog</span></div><div class="block text-center sm:inline-block sm:text-left sm:float-right"><a class="inline-block nav-link py-3 px-2" href="/">首页</a><a class="inline-block nav-link py-3 px-2" href="/archives/">归档</a><a class="inline-block nav-link py-3 px-2" href="/gallery/">相册</a><a class="inline-block nav-link py-3 px-2" href="/about/">关于</a><span class="inline-block nav-link py-3 px-2" id="btn_toggle_theme" title="切换暗色模式"><i class="theme-icon"></i></span></div></div></div><div class="blog-body pt-10 pb-10"><div class="container max-w-screen-lg px-3"><main class="flex"><article class="article-content mb-5 rounded p-5 w-full "><h1 class="text-xl md:text-2xl lg:text-2xl font-bold tracking-tighter leading-tight md:leading-none mb-6 text-center md:text-left">一个js数组分类求和算法</h1><p class="mb-5 text-sm"><span class="mr-3">发布日期：<!-- -->2020-02-28</span><span>文章字数：<!-- -->1.1<!-- -->K</span></p><div class="mx-auto"><div class="markdown-body"><p>需求详情：一个数组内有N个元素，元素有类型、名称、数量1、数量2等属性，计算出各类型元素的数量、数量1、数量2的和。</p>
<p>实际需求就是做出下图这样一个表格，各类型的合计信息用红色字体显示：</p>
<p><img src="https://images.liyangzone.com/article_img/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/%E5%85%B1%E7%94%A8/20200228_152031js%E5%88%86%E7%B1%BB%E6%B1%82%E5%92%8C%E7%AE%97%E6%B3%95.png"></p>
<p>原始数据格式如下：</p>
<pre><code class="js">const rawData = [
      &#123; type: &#39;类型A&#39;, name: &#39;名称1&#39;, count1: 13, count2: 24, count3: 34 &#125;,
      &#123; type: &#39;类型A&#39;, name: &#39;名称2&#39;, count1: 13, count2: 24, count3: 34 &#125;,
      &#123; type: &#39;类型A&#39;, name: &#39;名称3&#39;, count1: 13, count2: 24, count3: 34 &#125;,
      &#123; type: &#39;类型B&#39;, name: &#39;名称4&#39;, count1: 12, count2: 23, count3: 33 &#125;,
      &#123; type: &#39;类型B&#39;, name: &#39;名称5&#39;, count1: 12, count2: 23, count3: 33 &#125;,
      &#123; type: &#39;类型B&#39;, name: &#39;名称6&#39;, count1: 12, count2: 23, count3: 33 &#125;,
      &#123; type: &#39;类型C&#39;, name: &#39;名称7&#39;, count1: 11, count2: 25, count3: 35 &#125;,
      &#123; type: &#39;类型C&#39;, name: &#39;名称8&#39;, count1: 11, count2: 25, count3: 35 &#125;
    ]
</code></pre>
<p>算法思路：遍历该数组，按类型生成一个二维数组，再遍历该二级数组及其子元素，每遍历完一个类型的子元素后求和，并创建一个新的元素存储该类型元素的和，最后生成一个包含各类型元素数量的新数组，实现代码如下:</p>
<pre><code class="js">calcSum(arr) &#123;
      const newArr = [];
      arr.forEach((item, index) =&gt; &#123;
        let flag = 0;
        let k = 0;
        newArr.forEach((newItem, j) =&gt; &#123;
          if (newArr[j][0].type === arr[index].type) &#123;
            flag = 1;
            k = j;
          &#125;
        &#125;);
        if (flag) &#123;
          newArr[k].push(arr[index])
        &#125; else &#123;
          const tempArr = [];
          tempArr.push(arr[index]);
          newArr.push(tempArr);
        &#125;
      &#125;);

      const result = []
      newArr.forEach(subArr =&gt; &#123;
        let sum_name = 0;
        let sum_count1 = 0;
        let sum_count2 = 0;
        let sum_count3 = 0;

        subArr.forEach(subItem =&gt; &#123;
          sum_name += 1;
          sum_count1 += subItem.count1;
          sum_count2 += subItem.count2;
          sum_count3 += subItem.count3;
          result.push(subItem);
        &#125;);
        result.push(&#123;
          type: subArr[0].type,
           name: sum_name,
           count1: sum_count1,
           count2: sum_count2,
           count3: sum_count3,
           isSumRow: true //该属性标记为求和行
        &#125;)
      &#125;)
      return result;
    &#125;
</code></pre>
<p>生产的二维数组格式如下：</p>
<pre><code class="js"> newArr = [
        [
          &#123; &#39;type&#39;: &#39;类型A&#39;, &#39;name&#39;: &#39;名称1&#39;, &#39;count1&#39;: 13, &#39;count2&#39;: 24, &#39;count3&#39;: 34 &#125;,
          &#123; &#39;type&#39;: &#39;类型A&#39;, &#39;name&#39;: &#39;名称2&#39;, &#39;count1&#39;: 13, &#39;count2&#39;: 24, &#39;count3&#39;: 34 &#125;,
          &#123; &#39;type&#39;: &#39;类型A&#39;, &#39;name&#39;: &#39;名称3&#39;, &#39;count1&#39;: 13, &#39;count2&#39;: 24, &#39;count3&#39;: 34 &#125;
        ],
        [
          &#123; &#39;type&#39;: &#39;类型B&#39;, &#39;name&#39;: &#39;名称4&#39;, &#39;count1&#39;: 12, &#39;count2&#39;: 23, &#39;count3&#39;: 33 &#125;,
          &#123; &#39;type&#39;: &#39;类型B&#39;, &#39;name&#39;: &#39;名称5&#39;, &#39;count1&#39;: 12, &#39;count2&#39;: 23, &#39;count3&#39;: 33 &#125;,
          &#123; &#39;type&#39;: &#39;类型B&#39;, &#39;name&#39;: &#39;名称6&#39;, &#39;count1&#39;: 12, &#39;count2&#39;: 23, &#39;count3&#39;: 33 &#125;
        ],
        [
          &#123; &#39;type&#39;: &#39;类型C&#39;, &#39;name&#39;: &#39;名称7&#39;, &#39;count1&#39;: 11, &#39;count2&#39;: 25, &#39;count3&#39;: 35 &#125;,
          &#123; &#39;type&#39;: &#39;类型C&#39;, &#39;name&#39;: &#39;名称8&#39;, &#39;count1&#39;: 11, &#39;count2&#39;: 25, &#39;count3&#39;: 35 &#125;
        ]
      ]
</code></pre>
<p>最终数据格式如下,为了与普通的数据区分开，给求和的数据加上了一个isSumRow属性，用来生成一个className来标红：</p>
<pre><code class="js"> result = [
            &#123; &#39;type&#39;: &#39;类型A&#39;, &#39;name&#39;: &#39;名称1&#39;, &#39;count1&#39;: 13, &#39;count2&#39;: 24, &#39;count3&#39;: 34 &#125;,
            &#123; &#39;type&#39;: &#39;类型A&#39;, &#39;name&#39;: &#39;名称2&#39;, &#39;count1&#39;: 13, &#39;count2&#39;: 24, &#39;count3&#39;: 34 &#125;,
            &#123; &#39;type&#39;: &#39;类型A&#39;, &#39;name&#39;: &#39;名称3&#39;, &#39;count1&#39;: 13, &#39;count2&#39;: 24, &#39;count3&#39;: 34 &#125;,
            &#123; &#39;type&#39;: &#39;类型A&#39;, &#39;name&#39;: 3, &#39;count1&#39;: 39, &#39;count2&#39;: 72, &#39;count3&#39;: 102, &#39;isSumRow&#39;: true &#125;,
            &#123; &#39;type&#39;: &#39;类型B&#39;, &#39;name&#39;: &#39;名称4&#39;, &#39;count1&#39;: 12, &#39;count2&#39;: 23, &#39;count3&#39;: 33 &#125;,
            &#123; &#39;type&#39;: &#39;类型B&#39;, &#39;name&#39;: &#39;名称5&#39;, &#39;count1&#39;: 12, &#39;count2&#39;: 23, &#39;count3&#39;: 33 &#125;,
            &#123; &#39;type&#39;: &#39;类型B&#39;, &#39;name&#39;: &#39;名称6&#39;, &#39;count1&#39;: 12, &#39;count2&#39;: 23, &#39;count3&#39;: 33 &#125;,
            &#123; &#39;type&#39;: &#39;类型B&#39;, &#39;name&#39;: 3, &#39;count1&#39;: 36, &#39;count2&#39;: 69, &#39;count3&#39;: 99, &#39;isSumRow&#39;: true &#125;,
            &#123; &#39;type&#39;: &#39;类型C&#39;, &#39;name&#39;: &#39;名称7&#39;, &#39;count1&#39;: 11, &#39;count2&#39;: 25, &#39;count3&#39;: 35 &#125;,
            &#123; &#39;type&#39;: &#39;类型C&#39;, &#39;name&#39;: &#39;名称8&#39;, &#39;count1&#39;: 11, &#39;count2&#39;: 25, &#39;count3&#39;: 35 &#125;,
            &#123; &#39;type&#39;: &#39;类型C&#39;, &#39;name&#39;: 2, &#39;count1&#39;: 22, &#39;count2&#39;: 50, &#39;count3&#39;: 70, &#39;isSumRow&#39;: true &#125;
          ]
</code></pre>
</div><p class="date-info pt-8 font-bold leading-10 text-center hidden">本文发布于天前，文中所描述的信息可能已发生改变</p></div></article></main></div></div><footer class="blog-footer bg-neutral-50 border-neutral-200"><div class="container max-w-screen-lg px-3"><div class="md:flex justify-between block text-sm py-2"><div class="py-1 mx-3 text-center">Copyright © 2019 - 2022 <!-- -->liyang&#x27;s  blog<a href="http://beian.miit.gov.cn/"> 豫ICP备19028870号 </a></div><div class="py-1 mx-3 text-center"> Powered by<a href="https://nextjs.org/"> Next.js </a>&amp;<a href="https://hexo.io/"> Hexo </a>Created by liyang</div></div></div></footer></div></body><script id="DarkModeScript">
    let html = document.documentElement;
    let  colorScheme = localStorage.getItem('colorScheme')
    if(colorScheme&&colorScheme=='dark'){
      html.setAttribute('data-color-mode', 'dark')
    } else {
      html.setAttribute('data-color-mode', 'light')
    }
    let btn_toggle_theme = document.querySelector('#btn_toggle_theme');
    btn_toggle_theme.addEventListener('click', function () {
    let theme = html.dataset.colorMode;
      if (theme == 'light') {
        html.setAttribute('data-color-mode', 'dark')
        localStorage.setItem('colorScheme','dark');
      } else if (theme == 'dark') {
        html.setAttribute('data-color-mode', 'light')
        localStorage.setItem('colorScheme','light');
      }
    })</script><script id="DynamicLoadScript">
function PromiseForEach(arr, cb) {
    let realResult = []
    let result = Promise.resolve()
    arr.forEach((a, index) => {
      result = result.then(() => {
        return cb(a).then((res) => {
          realResult.push(res)
        })
      })
    })
    return result.then(() => {
      return realResult
    })
 }
function addScript(url) {
   return new Promise((resolve, reject) => {
     let script = document.createElement('script');
     script.src = url;
     document.documentElement.appendChild(script);
     script.onload = ()=>{
       return resolve('success')
     }
     script.onerror = ()=>{
       return reject('error')
     }
   })
 }     
function AddCss(url) {
      document.head.insertAdjacentHTML("beforeend", `<link rel="stylesheet" href="${url}">`);
}
</script><script id="ArticleTocScript">
       window.articleDate = '2020-02-28';
      let tocLinks = document.querySelectorAll('.toc-text');
      let targetLinks = document.querySelectorAll('.headerlink')
      tocLinks.forEach(function (link) {
        link.addEventListener('click', function (event) {
        let target = event.target
        event.preventDefault()
        event.stopPropagation()
        let parent = target.parentNode;
        let hash = decodeURI(parent.hash);
        let targetLink = Array.prototype.find.call(targetLinks, function (item) {
          return item.getAttribute('href') == hash
        })
        let top = targetLink.offsetTop
        window.scrollTo(0, top - 100)
        })
      })
      let dateInfoEle = document.querySelector('.date-info');
      var articleDate = new Date(window.articleDate)
    if(new Date().getTime()-articleDate.getTime()>180 * 24 * 3600 *1000){
      let date = Math.ceil((new Date().getTime()-articleDate.getTime())/24/3600/1000)
      dateInfoEle.style.display = 'block';
      dateInfoEle.innerText = `本文发布于${date}天前，文中所描述的信息可能已发生改变。`
    }
addScript('https://unpkg.com/@highlightjs/cdn-assets@11.5.0/highlight.min.js').then(res => {
   document.querySelectorAll('pre code').forEach((el) => {
    hljs.highlightElement(el);
  });
})     
      </script><script id="StatisticScript">
let runningOnBrowser = typeof window !== "undefined";
    let isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
let supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
    if(!isBot&&supportsIntersectionObserver){
      if(!navigator.userAgent.includes('Chrome/78')){
        addScript('https://hm.baidu.com/hm.js?3123469f7f81d45d6c4cd4a6a84ccf68');
        addScript('https://js.users.51.la/21306481.js');
      }
    }
  </script></html>